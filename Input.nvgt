//Input library for creating virtual and auditory interfaces
#include "Speech keys handle.nvgt"

//Constants
//Default maximum character
const uint16 dmc=511;
//Control types and events
enum controler
{
//Global values
none,
//Button settings
primary,
secondary,
//List index information reading settings
never,
once,
always,
//Edit field keyboard echo and navigation mode settings
letters,
words,
paragraphs,
all,
//Edit field typing events
letter,
number,
space,
symbol,
enter,
back,
capital,
//Edit field operations
select_all,
cut,
copy,
paste,
//Input events
open,
prev,
next,
edge,
ic,
prog,
//Check box events and settings
off,
half,
on,
//List item and edit field events
prevs,
nexts,
edges,
offs,
ons,
ics,
//Tab control events
prevo,
nexto
}

//Classes
class ctl
{
//Control class
//Is control in focus, private
private bool c;
//Is control disabled, private
private bool d;
//Control origin, private
private ctl@ o;
//Control name, private
private string n;
//Received event array, private
private uint8[] ents;

//Constructor
ctl()
{
res();
}

//Check if a given event exists
bool has(uint8 o)
{
return ents.find(o)>-1;
}

//Check if enter is blocked
bool ieb()
{
return false;
}

//Check if the control is in focus
bool ifs()
{
return c;
}

//Check if tab is blocked, specifying a scroll direction
bool itb(bool f)
{
return false;
}

//Original control loop, it should be specified in every control that has a loop
bool oract(bool f=false, bool g=false)
{
//Set control focus
c=f;
//Reset all recorded events
ents.resize(0);
//If g is true, return control disabled state
if(g==true)
return d;
//Otherwise, Return true if the control is disabled or not in focus
return d==true||f==false;
}

//Obtain the value of a checkbox
int8 checked()
{
//Only check boxes use this method
return 0;
}

//Get control name
string gen()
{
return n;
}

//Read control info, with an option to specify if the information is shorter
string inf(bool f=false)
{
//For text controls, return the control name
return n;
}

//Get control item
string itm()
{
//Only lists and edit fields use this method
return "";
}

//Original control info reading function, it should be applied to all versions of the read control info function
string orinf(bool f=false, string o="")
{
//Create info text
string t;
//If the control is in focus, add the info
if(f==true)
t=o;
//Otherwise
else
{
//Add control name
t=n;
//If control info is not blank, add it in a proper way
if(o!="")
t+=", "+o;
//If the control is disabled, add the word disabled in the end of the info
if(d==true)
t+=", disabled";
}
//Return info text
return t;
}

//Get control item position
uint ips()
{
//Only lists and control lists use this method
return 0;
}

//Make a slider
uint sl(string n="Enter a value", uint a=0, uint s=0, uint d=0, uint f=1)
{
//Only lists and menues use this method
return 0;
}

//Control loop, with an option to specify if the control is in focus
void act(bool f=false)
{
//Execute original loop
oract(f);
//If an arrow key is pressed, read the text for a text control
if(ak(1)||ak(2)||ak(3)||ak(4))
ict();
}

//Add a text to this control, optionally specifying a related control
void add(string o, ctl@ c=null)
{
//Only lists, edit fields and control lists use this method
}

//Change keyboard echo setting
void cke(uint8 o)
{
//Only edit fields use this method
}

//Change speaking of list information setting
void csi(uint8 o)
{
//Only lists and control lists use this method
}

//Delete something from this control
void del(uint p=0)
{
//Only lists, edit fields and control lists use this method
}

//Set control disabled state
void dis(bool o)
{
//If the control is in focus
if(c==true&&d!=o)
{
//Change control state and speak it
d=o;
spe(inf(true), false);
}
//Otherwise, Change control state as normal
else
d=o;
}

//Recognize control event, with an option to not send it to the control origin
void ent(uint8 e, bool q=false)
{
orent(e, q);
}

//Naturally interact with the control, with an option to do it quietly
void ict(bool q=false)
{
//If the interaction is quiet, do nothing
if(q==true)
return;
//Send a control interaction event
ent(ics);
//Speak a short information about the control
spe(inf(true));
}

//Original event recognition
void orent(uint8 e, bool q=false)
{
//If the event already exists, do nothing
if(has(e))
return;
//Add the event to the array
ents.insert_last(e);
//If not asked to be quiet and the control has an origin
if(q==false&&@o !is null)
//Send the receive event to the control origin
o.ent(e);
}

//Original reset
void orres(bool g=false)
{
c=false;
d=false;
if(g==false)
{
@o=null;
n="";
}
ents.resize(0);
}

//Reset control
void res(bool g=false)
{
orres(g);
}

//Set control origin
void sco(ctl@ t)
{
@o=t;
}

//Change the maximum characters of a control setting
void sem(uint16 o)
{
//Only lists and edit fields use this method
}

//Change control name
void sen(string o)
{
n=o;
if(c==true)
spe(inf(true), false);
}

//Change control position setting
void sep(int o)
{
//Only lists, edit fields, and progress bars use this method
}

//Change the state of a checkbox, or the purpose and press message of a button
void set(uint8 o, string p="")
{
//Only checkboxes and buttons use this method
}

//End
}

//Check a control array for an interacted control
uint8 cit(ctl@[] cols)
{
//Obtain the number of controls
uint8 l=cols.length();
//Run a loop
for(uint8 c=0; c<l; c++)
{
//If an interacted control is found, return it's proper index
if(@cols[c] !is null&&cols[c].has(ic)&&cols[c].ifs())
return c+1;
}
//Otherwise, return 0;
return 0;
}

class cbx : ctl
{
//Check box class, with properties and methods from control class
//Checkbox state, private
private int8 s;

//Obtain the value of a checkbox
int8 checked()
{
//This control is a checkbox and will return it's value
return s;
}

//Read control info
string inf(bool f=false)
{
//Info text
string o;
//If the control is not in focus, add control role
if(f==false)
o="Checkbox, ";
//Specify checkbox state in the info text
if(s==on)
o+="Checked";
else if(s==off)
o+="Not checked";
else if(s==half)
o+="Half checked";
else
o+="Unknown checkbox value "+s;
//Return control info
return orinf(f, o);
}

//Checkbox loop
void act(bool f=false)
{
//Execute original loop
if(oract(f))
//If the control is disabled or not in focus, do nothing
return;
//If space bar is pressed, toggle the checkbox
if(key_pressed(KEY_SPACE))
{
if(s==half||s==off)
s=on;
else
s=off;
ict();
}
}

//Check box interaction
void ict(bool q=false)
{
//Send checkbox state as an event
ent(s);
//If the interaction is quiet, do nothing
if(q==true)
return;
//Speak a short information about the control
spe(inf(true));
}

//Reset checkbox
void res(bool g=false)
{
s=0;
orres(g);
}

//Set checkbox state
void set(uint8 o, string p="")
{
s=o;
}

//End
}

class btn : ctl
{
//Button class, with properties and methods from control class
//Press message, private
private string m;
//Button purpose, private
private uint8 s;

//Read control info
string inf(bool f=false)
{
//If the control is in focus, return the press message
if(f==true)
return m;
//Otherwise, return normal info
return orinf(f, "Button");
}

//Button loop
void act(bool f=false)
{
//Execute original loop
if(oract(f, true))
//If the control is disabled, do nothing
return;
//Is button pressed
bool o=false;
//If the button is not focused
if(f==false)
{
//If the button is primary, check for presses of the continue keys
if(s==primary)
o=ck();
//If the button is secondary, check for presses of the cancel keys
else if(s==secondary)
o=cl();
}
//If the button is in focus and not pressed, check for presses of all continue keys
else if(f==true&&o==false)
o=ck(true);
//If the button is pressed, interact with it
if(o==true)
ict();
}

//Button interaction
void ict(bool q=false)
{
//If the interaction is quiet, do nothing
if(q==true)
return;
//Send a control interaction event
ent(ic);
//Speak a short information about the control
spe(inf(true));
}

//Reset button
void res(bool g=false)
{
s=0;
m="";
orres(g);
}

//Set the button's purpose and press message
void set(uint8 o, string p="")
{
s=o;
if(p=="")
p="Pressed";
m=p;
}

//End
}

class lbx : ctl
{
//List class, with properties and methods from control class
//List item cursor, private
private int s;
//Last written character, private
private string r;
//Written word, private
private string w;
//List item array, private
private string[] item;
//Multi letter navigation timer, private
private timer t;
//Setting for speaking list index information, private
private uint8 i=never;
//Maximum number of characters for an item name, private
private uint16 ms;
//Number of items, private
private uint l;

//Read control info
string inf(bool f=false)
{
//Info text
string o;
//If the control is not in focus, add control role
if(f==false)
o="List: ";
//If the cursor is not out of range
if(l>0&&s>=0&&s<l)
{
//Get the item name
string n=item[s];
//If the item name is greater than the maximum number of characters, cut the item name
if(n.length()>ms)
n.resize(ms);
//Add the item name on the cursor
o+=n;
}
//If set to speak index information, add item index information
if(i==always||(f==false&&i==once))
o+=", "+(s+1)+" of "+l;
//Otherwise, add an error message to the control info
else if(i!=always&&i!=once&&i!=never)
o+="Unknown list value "+i;
//Return control info
return orinf(f, o);
}

//Get control item name
string itm()
{
if(l>0&&s>=0&&s<l)
return item[s];
return "";
}

//Get control item position
uint ips()
{
return s;
}

//Get number of items
uint len()
{
return l+1;
}

//Original item delete
uint ordel(uint p=0)
{
//If there are no items, return 0
if(l==0)
return 0;
//Cursor position of the deleted item
uint o;
//If a custom cursor position is specified, delete the item from the cursor position
if(p>0)
{
o=p;
item.remove_at(p-1);
}
//Otherwise, remove the item at the original cursor position
else if(s>-1)
{
o=s+1;
item.remove_at(s);
}
//Decrease item count
l--;
//If the cursor ends up being higher than the item count, move the cursor back
if(s>=l)
s=l-1;
//Return the cursor position of the deleted item
return o;
}

//Make a slider in the list
uint sl(string n="Enter a value", uint a=0, uint s=0, uint d=0, uint f=1)
{
sen(n);
osl(a, s, d, f);
return 0;
}

//List loop
void act(bool f=false)
{
//Execute original loop
if(oract(f))
//If the control is disabled or not in focus, do nothing
return;
//Scroll through the list
if(ak(2))
scl(false);
if(ak(4))
scl(true);
if(ak(5))
scl(false, true);
if(ak(6))
scl(true, true);
//Passively perform multi letter navigation
wn();
//Read the item on the cursor
if(key_pressed(KEY_SPACE))
ict();
}

//Add an item to the list
void add(string o, ctl@ c=null)
{
//Perform adding
oradd(o);
}

//Change speaking of list information setting
void csi(uint8 o)
{
i=o;
}

//Delete the item at the specified position, or if no position is specified, delete the item at the cursor
void del(uint p=0)
{
ordel(p);
}

//List interact
void ict(bool q=false)
{
//If the interaction is quiet or there is a written word, do nothing
if(q==true||w!="")
return;
//Send a control interaction event
ent(ics);
//Speak a short information about the control
spe(inf(true));
}

//Original list reset
void itres(bool g=false)
{
s=0;
item.resize(0);
i=never;
ms=dmc;
l=0;
orres(g);
}

//Turn an array of strings into a list
void list(string[]@ list)
{
//If the menu is not empty, reset it
if(l>0)
res(true);
//Proceed as normal
item=list;
l=item.length();
}

//Original item add
void oradd(string o)
{
//If the item is blank, do nothing
if(o=="")
return;
//Add item and increase the item count
item.insert_last(o);
l++;
}

//Original slider creation, specifying the maximum value, the starting number on the left side, the default cursor position, and the number of steps
void osl(uint a=0, uint s=0, uint d=0, uint f=1)
{
//If the slider length or the number of steps is 0, do nothing
if(a==0||f==0)
return;
//If the list is not empty, reset it
if(l>0)
res(true);
//Create the slider
for(uint c=0; c<a; c+=f)
add(s+c);
}

//Reset list
void res(bool g=false)
{
itres(g);
}

//Scroll through a list, with options for scrolling backward or forward, and an option to jump to the first or last item
void scl(bool f, bool g=false)
{
//If g is false
if(g==false)
{
//Scroll back
if(f==false)
{
ent(prevs);
//If the list cursor is negative 1, put it to the first item
if(s==-1)
{
s=0;
ent(edges);
}
//Otherwise, scroll back while the item cursor is not on the first item
else if(s>0)
s--;
//Scrolling back is no longer possible
else
{
ent(edges);
return;
}
}
//Otherwise
else if(f==true)
{
ent(nexts);
//Scroll forward while the item cursor is not on the last item
if(s<l-1)
s++;
//Scrolling forward is no longer possible
else
{
ent(edges);
return;
}
}
}
//Otherwise
else if(g==true)
{
//Jump to the first item
if(f==false)
{
ent(edges);
if(s!=0)
s=0;
else
return;
}
//Jump to the last item
else if(f==true)
{
ent(edges);
if(s!=l-1)
s=l-1;
else
return;
}
}
//Speak the item on the cursor
spe(inf(true));
}

//Set cursor position
void sep(int o)
{
//If the new cursor is out of range, do nothing
if(o>l)
return;
//Set cursor position and allow a negative position
else if(o==-1||o>0)
s=o-1;
}

//Multi letter navigation
void wn()
{
//If the list is empty or running on android, do nothing
if(l==0||OS==OS_ANDROID)
return;
//If the navigation timer reached over 500 milliseconds
if(t.elapsed>500&&w!="")
{
//Reset the last written character and the written word
r="";
w="";
}
//Get the characters typed by the user
string k=get_characters();
//If nothing is typed, do nothing
if(k=="")
return;
//Lower case the character for accurate comparison
k.lower_this();
//Add the typed character to the written word
w+=k;
//Restart the navigation timer and send a character event
t.restart();
ent(letter);
//Is the list already cycled
bool i=false;
//Final cursor position
uint c=s;
//Old cursor position
uint os=s;
//Run a loop
while(true)
{
//If the list is already cycled and no matching item is found, exit the loop
if(c==s&&i==true)
break;
//Otherwise, increase the final cursor position
//If the end of the list is reached
if(c==l-1)
{
//Bring the cursor back to the first item
c=0;
//The list is now cycled
i=true;
}
else
c++;
//Lower case the name of the item on cursor for accurate comparison
string n=item[c].lower();
//If the item name begins with the written character, and the written character is same as the last written character
if(r==k&&n.starts_with(k))
{
//Set the cursor and exit the loop
s=c;
break;
}
//Otherwise, if the current item name begins with the written word
else if(n.starts_with(w))
{
//Set the cursor and exit the loop
s=c;
break;
}
}
//If the final cursor position is different from the old cursor position, speak the item on cursor
if(os!=s)
spe(inf(true));
//Set the written character as last written character
r=k;
}

//End
}

class lmn : lbx
{
//List menu class, with properties and methods from list class

//Run the menu
uint run(string n="", int k=0)
{
if(k==-1)
wait(100);
sen(n);
sep(k);
spe(inf());
while(true)
{
act(true);
if(cl())
{
ent(ic);
res(true);
return 0;
}
if(ck())
{
ent(ic);
break;
}
dwc();
}
return ips()+1;
}

//Create a slider in the menu
uint sl(string n="Enter a value", uint a=0, uint s=0, uint d=0, uint f=1)
{
//Specify control name and slider values
sen(n);
osl(a, s, d, f);
//Choice recorder
uint r;
//If the default cursor position is greater than 1, run the menu, setting the cursor in that position
if(d>1)
r=run(n, d);
//Otherwise, run the menu with the cursor at the original position
else
r=run(n);
//If the choice recorded is greater than 0, return the choice, multiplied by the number of steps for accuracy
if(r>0)
return r*f;
//Otherwise, return the original parameter of the slider if possible, multiplied by the number of steps for accuracy
return d*f;
}

//List menu loop
void act(bool f=false)
{
//Execute original loop
if(oract(f))
//If the control is disabled or not in focus, do nothing
return;
//Scroll through the list
if(ak(2))
scl(false);
if(ak(4))
scl(true);
if(ak(5))
scl(false, true);
if(ak(6))
scl(true, true);
//Read the item on the cursor
if(key_pressed(KEY_SPACE))
ict();
//Passively perform multi letter navigation
wn();
//Choose menu items
if(cl())
{
res(true);
ent(ic);
}
if(ck())
ent(ic);
}

//End
}

class efl : ctl
{
//Edit field class, with properties and methods from control class
//Written text, private
private string t;
//Written word, private
private string tw;
//Keyboard echo setting, private
private uint8 i;
//Text length, private
private uint l;
//Left cursor, private
private uint lc;
//Center cursor, private
private uint nc;
//Right cursor, private
private uint rc;
//Number of characters to be spoken before it is considered too long, private
private uint16 ms;

//Check if there is no text
bool nt()
{
//If there is no text, do some action and return true
if(l==0)
{
ent(edges);
say();
return true;
}
//Otherwise, return false
return false;
}

//Process characters
string char(string c)
{
if(c=="\n")
return "Line feed";
if(c=="\t")
return "Tab";
if(c==" ")
return "Space";
if(c.is_upper())
return "Capital "+c;
return c;
}

//Read control info
string inf(bool f=false)
{
//Info text
string o;
//If the control is not in focus, add control role
if(f==false)
o="Edit box: ";
//Add written text
o+=t;
//Return control info
return orinf(f, o);
}

//Get control item
string itm()
{
return t;
}

//Get a word starting from the given position
string word(uint p)
{
if(p<l)
return t.slice(p, t.find(" ", p));
return "";
}

//Alternative scrolling, with options for scroll amount, and an option to select text
void acl(int8 a, bool h=false)
{
//There is no text
if(nt())
return;
//If there is a written word, reset written word
if(tw!="")
tw="";
//Old cursor position,s used for speaking a word that starts from the old cursor positions
uint oc=lc;
uint pc=rc;
//Scroll back
if(a==-letters||a==-words)
{
//Scrolling back is still possible
if(rc>0)
{
//If the scroll amount is negative characters
if(a==-letters)
{
//If selection mode is on
if(h==true)
{
//If the right side cursor is greater than the center cursor, move the right side cursor back
if(rc>nc)
rc--;
//Otherwise, move the left side cursor back
else if(lc>0)
lc--;
}
//Otherwise, scroll back normally
if(h==false)
{
if(lc==rc)
{
rc--;
//Make the left side cursor follow the right side cursor
if(lc!=rc)
lc=rc;
}
//Make the center cursor follow the left side cursor
nc=lc;
}
}
//If the scroll amount is negative words
if(a==-words)
{
//If selection mode is on
if(h==true)
{
//If the right side cursor is greater than the center cursor
if(rc>nc)
{
//Run a special loop
do
//Move the right cursor back
rc--;
//As long as the character on the cursor is not a space
while(rc>0&&t[rc-1]!=" ");
}
//Otherwise
else
{
//Run a special loop
do
//Move the left side cursor back
lc--;
//As long as the character on the cursor is not a space
while(lc>0&&t[lc-1]!=" ");
}
}
//Otherwise
else
{
//Run a special loop
do
//Move cursor back
rc--;
//As long as the character on the cursor is not a space
while(rc>0&&t[rc-1]!=" ");
lc=rc;
nc=rc;
}
}
//Send a scroll back event
ent(prevs);
}
//Scrolling back is no longer possible
else
ent(edges);
}
//Scroll forward
if(a==letters||a==words)
{
//Scrolling forward is still possible
if(rc<l)
{
//If the scroll amount is positive characters
if(a==letters)
{
//If selection mode is on
if(h==true)
{
//If the left side cursor is lesser than the center cursor, move the left side cursor forward
if(lc<nc)
lc++;
//Otherwise, scroll forward
else
rc++;
}
//If selection mode is off, scroll forward normally
if(h==false&&lc==rc)
{
rc++;
if(lc!=rc)
lc=rc;
}
}
//If the scroll amount is positive words
if(a==words)
{
//If the left side cursor is lesser than the center cursor
if(lc<nc)
{
//Run a special loop
do
//Move the left cursor forward
lc++;
//As long as the character on the cursor is not a space
while(lc<l&&t[lc-1]!=" ");
}
//Otherwise
else
{
//Run a special loop
do
//Move cursor forward
rc++;
//As long as the character on the cursor is not a space
while(rc<l&&t[rc-1]!=" ");
}
if(h==false)
lc=rc;
}
//Send a scroll forward event
ent(nexts);
}
//Scrolling forward is no longer possible
else
ent(edges);
//If selection mode is off, make the center cursor follow the right side cursor
if(h==false)
nc=rc;
}
//Jump to the first character
if(a==-all)
{
//If selection mode is on and selection has not started, jump the left side cursor to the first character
if(h==true&&lc>0&&lc==rc)
{
lc=0;
ent(prevs);
}
//Otherwise, jump back nomally
else if(rc>0)
{
rc=0;
lc=rc;
nc=rc;
ent(prevs);
}
//Scrolling back is no longer possible
else
ent(edges);
}
//Otherwise, jump to the last character
if(a==all)
{
//Jump the right side cursor to the last character
if(rc<l)
{
rc=l;
//If selection mode is off, jump all cursor
if(h==false)
{
lc=rc;
nc=rc;
}
ent(nexts);
}
//Scrolling forward is no longer possible
else
ent(edges);
}
//If selection mode is on
if(h==true&&has(edges)==false)
{
//If set to jump, read selected text
if(a==-all||a==all)
rels(h);
//Read selected or unselected text while scrolling back
if(a==-letters||a==-words)
{
//Unselected from the right side cursor
if(lc==nc&&rc>=nc&&rc<l)
{
if(a==-words)
rems(word(rc), false);
if(a==-letters)
rems(t[rc], false);
}
//Selected from the left side cursor
else if(lc<l)
{
if(a==-words)
rems(word(lc), h);
if(a==-letters)
rems(t[lc], h);
}
}
//Read selected or unselected text while scrolling forward
if(a==letters||a==words)
{
//Unselected from the left side cursor
if(nc==rc&&lc<=nc)
{
if(a==words)
rems(word(oc), false);
if(a==letters)
rems(t[lc-1], false);
}
//Selected from the right side cursor
else if(rc>0)
{
if(a==words)
rems(word(pc), h);
if(a==letters)
rems(t[rc-1], h);
}
}
}
//If selection mode is off
else if(h==false)
{
//Read character
if(a==-letters||a==-all)
say(t[lc]);
if(a==letters||a==all)
{
if(rc<l)
say(t[rc]);
else
say();
}
//Read word
if(a==-words||a==words)
spe(word(rc));
//If a selection was previously made
if(lc!=rc)
{
//Read selection
rels(h);
//Reset selection parameters
if(a==-letters||a==-all)
rc=lc;
else if(a==letters||a==all)
lc=rc;
}
}
}

//Edit field loop
void act(bool f=false)
{
//Execute original loop
if(oract(f))
//If the control is disabled or not in focus, do nothing
return;
//Character delete
if(key_pressed(KEY_BACK))
del();
//Edit field operations
if(ct())
{
//Select all text
if(key_pressed(KEY_A))
tels();
//Cut and copy to clipboard
if(key_pressed(KEY_X))
cpt(true);
if(key_pressed(KEY_C))
cpt();
//Paste clipboard content
if(key_pressed(KEY_V))
{
ent(paste);
string o=clipboard_get_text();
if(o=="")
spe("There is no text on the clipboard");
else
add(o);
}
}
//Scroll through the edit field
if(ak(1))
{
if(ct())
{
if(sf())
acl(-words, true);
else
acl(-words);
}
else
{
if(sf())
acl(-letters, true);
else
acl(-letters);
}
}
if(ak(3))
{
if(ct())
{
if(sf())
acl(words, true);
else
acl(words);
}
else
{
if(sf())
acl(letters, true);
else
acl(letters);
}
}
if(ak(2)||ak(4))
ict();
if(ak(5))
{
if(sf())
acl(-all, true);
else
acl(-all);
}
if(ak(6))
{
if(sf())
acl(all, true);
else
acl(all);
}
//Add recognized characters
add(get_characters());
}

//Add text
void add(string o, ctl@ c=null)
{
//If the string is blank, do nothing
if(o=="")
return;
//Otherwise, add the string to the text at the cursor position
t.insert(rc, o);
//Obtain the number of written characters
uint n=o.length();
//Move cursor forward
lc+=n;
nc+=n;
rc+=n;
//Increase character count
l+=n;
//A symbol is written
if(o.is_punctuation())
ent(symbol);
//A space is written
else if(o==" ")
ent(space);
//A number is written
else if(o.is_digits())
ent(number);
//A letter is written
else
ent(letter);
//If keyboard echo is set to letters or all
if(i==letters||i==all)
{
//If keyboard echo is set to all and the string is a symbol or a space, do not read it
if(!(i==all&&(o.is_punctuation()||o==" ")))
//Otherwise, read it
say(o);
}
//If keyboard echo is set to words or all
if(i==words||i==all)
{
//If the string is a symbol or a space
if(o.is_punctuation()||o==" ")
{
//If there is a recorded word, speak and reset it
if(tw!="")
{
spe(tw);
tw="";
}
//If keyboard echo is set to all, speak the string with delay
if(i==all)
say(o, true);
}
//Otherwise, add the string to the written word
else
tw+=o;
}
}

//Change keyboard echo setting
void cke(uint8 o)
{
i=o;
}

//Copy or cut
void cpt(bool u=false)
{
//If no selection is made, do nothing
if(lc==rc)
{
spe("No selection");
return;
}
//Copy the selected string to the clipboard
clipboard_set_text(t.slice(lc, rc));
//If cut is true
if(u==true)
{
//Delete selected text
ent(cut);
spe("Cut");
dels();
//Reset selection parameters
rc=lc;
}
//Otherwise, just copy the text
else
{
ent(copy);
spe("Copy");
}
}

//Delete text
void del(uint p=0)
{
//If the text is blank, do nothing
if(nt())
return;
//Reset written word
tw="";
ent(back);
//If a selection is made
if(lc!=rc)
{
//Delete selected text
dels();
//Say the new character in the cursor position
if(rc>0)
say(t[rc-1]);
//There is no character
else
say();
//Reset selection
spe("Selection removed", false);
lc=rc;
}
//Otherwise
else if(rc>0)
{
//Remove the character at the cursor
say(t[rc-1]);
t.erase(rc-1, 1);
//Move cursor back
lc--;
rc--;
//Decrease character count
l--;
}
}

//Delete selected text
void dels()
{
//If no selection is made, do nothing
if(lc==rc)
return;
//Calculate cursor position difference
uint dc=rc-lc;
//Remove selected string
t.erase(lc, dc);
//Move cursor back
rc-=dc;
//Decrease text count
l-=dc;
}

//Read text selection, using the given selection mode as a parameter
void rels(bool h)
{
//If no selection is made, do nothing
if(lc==rc)
return;
//Otherwise, read selected text as normal
rems(t.slice(lc, rc), h);
}

//Read manual string, using the given selection mode as a parameter
void rems(string t, bool h)
{
//Obtain the number of characters
uint n=t.length();
//If the number of characters is greater than the selectable text amount, speak how many characters are selected
if(n>ms)
t=n+" characters";
//Info
string o;
//Selection mode is on
if(h==true)
o="Selected";
//Selection mode is off
else
o="Unselected";
//Read selected text
spe(char(t)+" "+o, false);
}

//Reset edit field
void res(bool g=false)
{
t="";
tw="";
i=0;
ms=dmc;
l=0;
lc=0;
nc=0;
rc=0;
orres(g);
}

//Speak a text in a proper way, with an option to specify if speec should be delayed
void say(string w="", bool d=false)
{
spe(char(w), !d);
}

//Set maximum number of selectable characters
void sem(uint16 o)
{
ms=o;
}

//Select the entire text
void tels()
{
//There is no text
if(nt())
return;
//Otherwise, select the entire text
ent(select_all);
lc=0;
rc=l;
//Read selection
rels(true);
}

//End
}

class pgs : ctl
{
//Progress bar class, with properties and methods frmo control class
//Is progress bar global, private
bool g=true;
//Progress bar timer, private
private timer t;
//Progress bar value, private
private uint8 v=0;
//Progress bar time, private
private uint16 l=1000;

//Get the value of the progress bar
uint ips()
{
return v;
}

//Progress bar loop
void act(bool f=false)
{
//Execute original loop
if(oract(f, true))
//If the control is disabled, do nothing
return;
//If progress bar time is specified and the progress bar timer reaches progress bar time, restart progress bar timer
if(l>0&&t.elapsed>l)
{
ent(prog);
t.restart();
}
}

//Reset progress bar
void res(bool g=false)
{
g=true;
v=0;
l=0;
orres(g);
}

//Change the timer of the progress bar
void sep(int o)
{
if(o>=0)
l=o;
}

//Set the value of the progress bar
void set(uint8 o, string p="")
{
v=o;
}

//End
}

class tab : ctl
{
//Tab class, with properties and methods from control class
//Control handle array, private
private ctl@[] cols;
//Keyboard echo, private
private uint8 ke=none;
//Number of controls, private
private uint8 l=0;
//Current control in focus, private
private uint8 s=0;
//Speak list index information, private
private uint8 si=never;

//Check if tab is blocked, specifying if shift is held
bool itb(bool f)
{
//If there are no controls, tab is not blocked
if(l==0)
return false;
//If scrolling back and the control cursor is at the first control, do not block
if(f==false&&s==0)
return false;
//If scrolling forward and the control cursor is at the last control, do not block
if(f==true&&s==l-1)
return false;
//Otherwise, block as normal
return true;
}

//Original function to scroll back or forward, with an option to wrap the scrolling
bool oscl(bool f, bool g=false)
{
//If there are 0 or 1 controls, return false
if(l<=1)
return false;
//If the current control is empty, return false
if(@cols[s] is null)
return false;
//Scroll backward
if(f==false)
{
//Send scrolling events
ent(prev);
if(s>0)
s--;
//Optionally wrap
else if(g==true)
{
ent(edge);
s=l-1;
}
//Send tab scrolling event to the current control
cols[s].ent(prevo, true);
}
//Scroll forward
else
{
//Send scrolling events
ent(next);
if(s<l-1)
s++;
//Optionally wrap
else if(g==true)
{
ent(edge);
s=0;
}
//Send tab scrolling event to the current control
cols[s].ent(nexto, true);
}
//Read control information and return true
read(false, true);
return true;
}

//Add control with a given name
ctl@ add_control(ctl@ c, string n)
{
//If the control or control name is not specified, do nothing
if(@c is null||n=="")
return null;
//Otherwise, specify the name of the control
c.sen(n);
//Specify the origin of the control
c.sco(this);
//Add it to the control array
cols.insert_last(c);
//Increase number of controls
l++;
//Return the control
return c;
}

//Add button with the given purpose and an optional button press message
ctl@ add_button(string n, uint8 o=0, string p="")
{
//Create new control
btn b;
//Define the purpose and the press message of the button
b.set(o, p);
//If there is no press message defined, make a default one
if(p=="")
p="Pressed";
//Add and return the control
return add_control(b, n);
}

//Add checkbox and define it's state
ctl@ add_checkbox(string n, uint8 o=0)
{
//Create control
cbx c;
//Specify checkbox state
c.set(o);
//Add and return the control
return add_control(c, n);
}

//Add edit field, optionally specifying a default text and optionally defining a different keyboard echo setting
ctl@ add_edit(string n, string t="", uint8 k=0)
{
//Make edit field
efl e;
//If a text is specified, add it
e.add(t);
//Configure edit field
if(k>0)
e.cke(k);
else
e.cke(ke);
//Add and return the control
return add_control(e, n);
}

//Add list, optionally specifying how list information should be spoken
ctl@ add_list(string n, uint8 i=0)
{
//Create new control
lbx l;
//Configure list information speaking
if(i>0)
l.csi(i);
else
l.csi(si);
//Add and return the control
return add_control(l, n);
}

//Add list with a given set of items, optionally specifying a starting cursor position and how list information should be spoken
ctl@ add_list(string n, string[]@ item, int p=0, uint8 i=0)
{
//Create new control
lbx l;
//Provide the given list of items
l.list(item);
//Set list cursor position
l.sep(p);
//Configure list information speaking
if(i>0)
l.csi(i);
else
l.csi(si);
//Add and return the control
return add_control(l, n);
}

//Add menu, optionally specifying how list information should be spoken
ctl@ add_menu(string n, uint8 i=0)
{
//Create new control
lmn l;
//Configure list information speaking
if(i>0)
l.csi(i);
else
l.csi(si);
//Add and return the control
return add_control(l, n);
}

//Add menu with a given set of items, optionally specifying a starting cursor position and how list information should be spoken
ctl@ add_menu(string n, string[]@ item, int p=0, uint8 i=0)
{
//Create new control
lmn l;
//Provide the given list of items
l.list(item);
//Set list cursor position
l.sep(p);
//Configure list information speaking
if(i>0)
l.csi(i);
else
l.csi(si);
//Add and return the control
return add_control(l, n);
}

//Add progress bar
ctl@ add_progress_bar(string n, uint16 l=0, uint8 v=0)
{
//Create control
pgs p;
//Specify progress bar configurations
p.set(v);
p.sep(l);
//Add and return the control
return add_control(p, n);
}

//Add text
ctl@ add_text(string n)
{
//Create new control
ctl c;
//Add and return the control
return add_control(c, n);
}

//Read control info
string inf(bool f=false)
{
//Info text
string o;
//If the control is not in focus, add control role
if(f==false)
o+=", Property page: ";
//If the control cursor is not out of range and the control cursor is not empty
if(l>0&&s<l&&cols[s] !is null)
//Add control info
o+=cols[s].inf(false);
return orinf(f, o);
}

//Tab loop
void act(bool f=false)
{
//Execute original loop
if(oract(f, true))
//If the control is disabled, do nothing
return;
//Shift press checker
bool b=!sf();
//Current control tab block checker
bool t=cols[s].itb(b);
//If tab is not blocked
if(t==false)
{
//Scroll to the next or previous control
if(key_pressed(KEY_TAB))
scl(b);
}
//Run a loop
for(uint c=0; c<l; c++)
{
//If the current control is empty, continue
if(@cols[c] is null)
continue;
//If the currently selected control is found, execute it's loop with focus on
if(c==s)
cols[c].act(true);
//Otherwise, execute the loop normally
else
cols[c].act();
}
}

//Add tab
void add_tab(string o, lsc@ c)
{
ctl@ r=c.pc();
add_control(c, o);
if(@r !is null)
add_control(r, o);
}

//Set keyboard echo setting for all edit fields
void cke(uint8 o)
{
//Set setting
ke=o;
//Run a loop
for(uint16 c=0; c<l; c++)
{
//Do not work if the control is empty
if(@cols[c] !is null)
//Influence all edit fields
cols[c].cke(o);
}
}

//Set speak list index setting for all lists
void csi(uint8 o)
{
//Set setting
si=o;
//Run a loop
for(uint16 c=0; c<l; c++)
{
//Do not work if the control is empty
if(@cols[c] !is null)
//Influence all lists
cols[c].csi(o);
}
}

//Tab event recognition
void ent(uint8 e, bool q=false)
{
if(e==prevo&&l>0&&s<l-1)
s=l-1;
if(e==nexto&&l>0&&s>0)
s=0;
orent(e, q);
}

//Read current control information, with an option to specify if the control is focused and information is not being read for the first time
void read(bool f=false, bool d=false)
{
//Do not work if there are no controls or the cursor is out of range
if(l==0||s<0||s>l)
return;
//If the current control is empty, do nothing
if(@cols[s] is null)
return;
//Quietly interact with the control
cols[s].ict(true);
//Read the control information
spe(cols[s].inf(f), !d);
}

//Reset tab
void res(bool g=false)
{
for(uint8 c=0; c<l; c++)
@cols[c]=null;
cols.resize(0);
ke=none;
l=0;
s=0;
si=never;
orres(g);
}

//Scroll to the previous or next control
void scl(bool f)
{
oscl(f);
}

//Set the control cursor to a specified position, with an option to specify if the action should be done quietly
void set(uint8 i, bool q=false)
{
//Only set the cursor if the new position is less than or equal to the number of controls
if(i<=l)
s=i-1;
//If not asked to be quiet, read the information of the newly selected control
if(q==false)
read();
}

//End
}

//Make a tab to add controls in
tab@ new_tab()
{
tab t;
return t;
}

class lsc : lbx
{
//Control list class, with methods and properties from list class
//Property page control handle, private
private ctl@ p;
//Tab handle array, private
private ctl@[] tabs;

//Provide property page handle
ctl@ pc()
{
return p;
}

//Control list loop
void act(bool f=false)
{
//Execute original loop
if(oract(f))
//If the control is disabled or not in focus, do nothing
return;
//Scroll through the tab list
if(ak(1))
scl(false);
if(ak(3))
scl(true);
if(ak(5))
scl(false, true);
if(ak(6))
scl(true, true);
//Read the item on the cursor
if(key_pressed(KEY_SPACE))
ict();
}

//Add a control, a related control must be specified for it to work
void add(string o, ctl@ c=null)
{
//If there is no name or related control given, do nothing
if(o==""||@c is null)
return;
//Otherwise, name the control, then add the name and the tab into their respective arrays
c.sen(o);
oradd(o);
tabs.insert_last(c);
//Set the last added control as the property page control
@p=c;
}

//Delete a control
void del(uint p=0)
{
//Obtain the cursor position of the deleted tab
uint o=ordel(p);
//If the cursor is greater than 0, delete a tab
if(o>0)
{
@tabs[o-1]=null;
tabs.remove_at(o-1);
}
}

//Reset control list
void res(bool g=false)
{
@p=null;
uint n=len();
for(uint c=0; c<n; c++)
@tabs[c]=null;
tabs.resize(0);
itres(g);
}

//End
}

class ipt : tab
{
//Input class, with properties and methods from tab class

//Run the input with the specified title and focused control id
void run(string t="", uint8 i=0)
{
//Check if the input has a title
string n=gen();
//If running for the first time, wait for a while and set input title
if(n=="")
{
wait(100);
n=t;
sen(t);
}
//Speak input title
spe(n+", dialog");
//If i is greater than 0, quietly set control cursor to i
if(i>0)
set(i, true);
//Read current control information with delay
read(false, true);
//Send a control open event
ent(open);
//Clear characters
get_characters();
}

//Scroll to the previous or next control
void scl(bool f)
{
oscl(f, true);
}

//End
}

//Global object: Input
ipt i;

//End
